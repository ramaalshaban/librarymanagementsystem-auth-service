# Service Design Specification

**Athentication documentation**
-Version:**`1.0.1`**

## Scope

This document provides a structured architectural overview of the `authentication` module of the project.The `authentication` module of the project is used to generate authentication and authorization specific code for all services
but a more specific purpose of the module is also to store all required configuration to generate an automatic user service for the project which is named 'librarymanagementsystem-auth-service'.

So in this document you will find

- The detailed configuration of the authetication module.

- The effect of the authetication configuration on the auth (user) service and the detailed structures of the auto-generated user service.

- The effect of the authetication configuration on the resource services and the detailed authentication and authorization structures of a resource server.

This document has been automatically generated based on the authetication module definition within Mindbricks, ensuring that the information reflects the source of truth used during code generation and deployment.

The document is intended to serve multiple audiences:

- **Service architects** can use it to validate design decisions and ensure alignment with broader architectural goals.
- **Developers and maintainers** will find it useful for understanding the structure and behavior of the service, facilitating easier debugging, feature extension, and integration with other systems.
- **Stakeholders and reviewers** can use it to gain a clear understanding of the service's capabilities and domain logic.

> **Note for Frontend Developers**: While this document is valuable for understanding business logic and data interactions, please refer to the [Service API Documentation](#) for endpoint-level specifications and integration details.

> **Note for Backend Developers**: Since the code for this service is automatically generated by Mindbricks, you typically won't need to implement or modify it manually. However, this document is especially valuable when you're building other services—whether within Mindbricks or externally—that need to interact with or depend on this service. It provides a clear reference to the service's data contracts, business rules, and API structure, helping ensure compatibility and correct integration.

## Authentication Essentials

Mindbricks provides a comprehensive authentication module that serves as the foundation for user management and security across all services.
This module is designed to be flexible, allowing for the generation of authentication and authorization code tailored to project's specific needs.
Mindbricks supports multiple authentication strategies, for the first validation of the user, the auth service supports the following authentication strategies:

- **Password-based authentication**: Users can log in using a username and password.
- **Social login**: Users can authenticate using third-party providers like Google, Facebook, or GitHub.
- **Single Sign-On (SSO)**: Users can log in using an SSO provider, allowing for seamless access across multiple applications.
- **API Key**: Services can authenticate using API keys for secure communication.
  Once the user is validated through one of the above strategies, the user is granted a JWT token that can be used to access the protected resources of the service.

JWT tokens are generated by the auth service and can be used to access protected resources of the service.
The JWT token is open and contains the user's identity and any additional claims required for authorization.
The token is signed using a private RSA key, ensuring its integrity and authenticity.
Once the JWT token is generated, it can be used to access protected resources of the service.

The JWT token is structured as follows:

```json
{
  "keyId": "716a8738ec3d499f84d58bda6ee772ce",
  "sessionId": "9cf23fa8-07d4-4e7c-80a6-ec6d6ac96bb9",
  "userId": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "sub": "d92b9d4c-9b1e-4e95-842e-3fb9c8c1df38",
  "loginDate": "2023-10-01T12:00:00Z"
}
```

Key id for a token represents the private-public key pair used to sign the token. To validate the signature of the token,
the public key is used. Any service which will use the JWT token can request a publick ket from the auth service using the following endpoint:

```http
GET /publickey?keyId=[keyIdInToken]
```

Mindbricks generated services manages the key rotation automatically, so the public key is always up to date and valid for the JWT tokens generated by the auth service.
If you add any manual service to the project which should validate the JWT token, you can use the public key endpoint to get the public key and validate the JWT token signature.

The JWT token life cycle is configured in the authentication module of the project. This project uses the following configuration for the JWT token:
The token is valid for days after it is issued.
And the private key used to sign the token is rotated every days.

Note that when a new key is generated to sign the JWT tokens, the old key is still valid for the period of days.
So it is recommended to cache the old public keys for the period of days to validate the JWT tokens issued with the old keys.

## The Login Definition

The login definition is a crucial part of the authentication module, as it defines how user and tenant model is defined.
In this section it is specified how users, user groups, and tenants are defined in the project's data model.
These definitions allow Mindbricks to dynamically extract identity and authorization data from project-specific data objects.

### User Settings

**Super Admin User Email**: `admin@aadmin.com`\*\*
The login email of the super admin user. This user has full permissions across the project and is not tenant-scoped.
If not defined, the project owner's email is used.
This email must be unique and valid to support email-based features like verification and password reset.

Super admin user is created automatically when the project is initialized with a roleId of `superAdmin` and a userId of `f7103b85-fcda-4dec-92c6-c336f71fd3a2`.

**Super Admin User Password**: Super admin user password is defined in this module as well, but masked in this document.
To edit it you can use the **User Settings** section of **Login Definition** chapter of the Mindbricks **Authentication Module**.

**Username Type**:
The type of the username which is stored in the database and written to the session object for information purposes.: -`asFullName`: The username is stored in one property, `fullname`, and represents the full name of the user, which is a combination of first name and last name. -`asNamePair`: The username is stored in two properties, `name` and `surname`, which are combined to form the full name of the user.

This project uses the `asNamePair` type, so the user name is stored in two properties, `name` and `surname`, which are combined to form the full name of the user.
The session object will contain the `fullname` property, which is a combination of `name` and `surname` as well as the `name` and `surname` properties.

**User Groups**:
The project supports user groups, which are used to group users together for easier management and authorization.
Since user grups are enabled, the auth service will automaticall create a `userGroup` and `userGroupMember` data objects
that will store the user groups and their members. You can create and manage user groups and
their members using the related crud routes defined in this document.

**Public User Registration**:
The project allows public user registration, meaning that users can register themselves without the need for an admin to create an account for them.
This is useful for projects that require user self-registration, such as social networks, forums, or any application where users need to create their own accounts.
The user registration process is handled by the auth service, which will create a new user data object in the database.
The user registration process will create a new user with the `userId` and `roleId` set to `user`, and the user will be able to log in using the username and password
they provided during registration. The reigstered user's roleId will be updated later to any other roleId by the super admin or admin users.
If any social login is enabled for the project, the user can also sign up using the social login providers. Note that when users register themselves using socila logi,
first all the data that can be provided by the social login provider will written to Redis cache with a key called socialCode,
and this code will be returned to the api consumer, which can be used to complete the registration process.

**Email Verification Required For Login**:
The project requires email verification for user login, meaning that users must verify their email address before they can log in.
This is useful for projects that require email verification to ensure that users have provided a valid email address, such as social networks, forums, or any application where email verification is required.
The email verification process is handled by the auth service, which will send a verification email to the user's email address after they register or change their email address.
You can check the email verification details in the REST API documentation of the auth service.

**Email 2FA Is Not Required For Login**:
The project does not require email-based two-factor authentication (2FA) for user login, meaning that users can log in using only their username and password without providing a second factor of authentication.
This is useful for projects that do not require an additional layer of security for user login, such as enterprise applications, internal tools, or any application where email-based 2FA is not required.
While the email 2FA is not required, the auth service will still support email 2FA if it is configured in the verification services.
You can prefer email 2FA at any time before any action or make it optional which means that users can provide a second factor of authentication if they want to, but it is not required for
login. You can check the email 2FA details in the REST API documentation of the auth service.

**User Mobile Active**: The authetication module is configured to support mobile numbers for users.
This means that the user data object will contain a `mobile` property that will be used to store the user's mobile number.
This is useful for projects that require mobile numbers for users, such as two-factor authentication, SMS notifications, or any application where mobile numbers are required.
The mobile number is required to be given by the user during registration, and it will be used to send SMS notifications or for two-factor authentication.

**Mobile Verification Is Not Required For Login**:
The project does not require mobile number verification for user login, meaning that users can log in without verifying their mobile number.
This is useful for projects that do not require mobile number verification, such as enterprise applications, internal tools, or any application where mobile number verification is not required.
The mobile verification process is not handled by the auth service, and users can log in without verifying their mobile number.
While the mobile verification is not required, the auth service will still support mobile verification if it is configured in the verification services.
You can prefer mobile verification at any time before any action or make it optional which means that users can verify their mobile number if they want to, but it is not required for login.
You can check the mobile verification details in the REST API documentation of the auth service.

**Mobile 2FA Is Not Required For Login**:
The project does not require mobile-based two-factor authentication (2FA) for user login, meaning that users can log in using only their username and password without providing a second factor of authentication.
This is useful for projects that do not require an additional layer of security for user login, such as enterprise applications, internal tools, or any application where mobile-based 2FA is not required.
While the mobile 2FA is not required, the auth service will still support mobile 2FA if it is configured in the verification services.
You can prefer mobile 2FA at any time before any action or make it optional which means that users can provide a second factor of authentication if they want to, but it is not required for login.
You can check the mobile 2FA details in the REST API documentation of the auth service.

**User Auto Avatar Script**:
Mindbricks stores an avatar property inthe user data model automatically.
This project supports also automatic avatar generation for users with the following script configuretion.
The auth service will generate an avatar for each user when it is not specified in the registration process.

The script is defined in the authentication module and can be edited in the **User Settings** section of **Login Definition** chapter of the Mindbricks **Authentication Module**.
The script is executed when a new user is created, and it generates an avatar based on user properties.

```js
`https://gravatar.com/avatar/${LIB.common.md5(this.email ?? "nullValue")}?s=200&d=identicon`;
```

### Tenant Settings

This project is not configured to support multi-tenancy, meaning that users and other data are not scoped to a specific tenant.
This allows for a single-tenant data management, where all users and other data are shared across the project.

## Verification Services

The project supports various verification services that enhance security and user experience.
These services are designed to verify user identity through different channels, such as email and mobile,
and can be configured to suit the project's needs. Please check the auth service API documentation for more details on how to use these services through the REST API.

A verification service is configured with the following settings: -`verificationType`: The type of verification handling, which can be one of the following:
-- `byCode`: The verification is handled by entering a code in the frontend.
-- `byLink`: The verification is handled by clicking a link in the frontend, which will automatically verify the user through the auth service. -`resendTimeWindow`: The time window in seconds during which the user can request a new verification code or link. -`expireTimeWindow`: The time window in seconds after which the verification code or link will expire and become invalid.

### Password Reset By Email

The project supports password reset by email, allowing users to reset their passwords securely through a verification code sent to their registered email address.
This service is useful for projects that require users to reset their passwords securely, such as social networks, forums, or any application where password reset is required.
The password reset by email process is handled by the auth service, which will send a verification code to the user's email address after they request a password reset.

```json
{
  "verificationType": "byLink",
  "resendTimeWindow": 60,
  "expireTimeWindow": 86400
}
```

### Password Reset By Mobile

The project supports password reset by mobile, allowing users to reset their passwords securely through a verification code sent to their registered mobile number.
This service is useful for projects that require users to reset their passwords securely, such as social networks, forums, or any application where password reset is required.
The password reset by mobile process is handled by the auth service, which will send a verification code to the user's mobile number after they request a password reset.

```json
{
  "verificationType": "byLink",
  "resendTimeWindow": 60,
  "expireTimeWindow": 86400
}
```

### Email Verification

The project supports email verification, allowing users to verify their email addresses securely through a verification code sent to their registered email address.
This service is useful for projects that require users to verify their email addresses securely, such as social networks, forums, or any application where email verification is required.
The email verification process is handled by the auth service, which will send a verification code to the user's email address after they register or change their email address.

```json
{
  "verificationType": "byLink",
  "resendTimeWindow": 60,
  "expireTimeWindow": 86400
}
```

### Mobile Verification

The project supports mobile verification, allowing users to verify their mobile numbers securely through a verification code sent to their registered mobile number.
This service is useful for projects that require users to verify their mobile numbers securely, such as social networks, forums, or any application where mobile verification is required.
The mobile verification process is handled by the auth service, which will send a verification code to the user's mobile number after they register or change their mobile number.

```json
{
  "verificationType": "byLink",
  "resendTimeWindow": 60,
  "expireTimeWindow": 86400
}
```

### Email 2FA

The project supports email-based two-factor authentication (2FA), allowing users to enhance their login security
by providing a second factor of authentication, such as a verification code sent to their registered email address.
This service is useful for projects that require an additional layer of security for user login, such as social networks, forums, or any application where email-based 2FA is required.
The email 2FA process is handled by the auth service, which will send a verification code to the user's email address after they log in.
The user must provide the verification code to complete the login process.

```json
{
  "verificationType": "byLink",
  "resendTimeWindow": 60,
  "expireTimeWindow": 86400
}
```

### Mobile 2FA

The project supports mobile-based two-factor authentication (2FA), allowing users to enhance their login security
by providing a second factor of authentication, such as a verification code sent to their registered mobile number.
This service is useful for projects that require an additional layer of security for user login, such as  
social networks, forums, or any application where mobile-based 2FA is required.
The mobile 2FA process is handled by the auth service, which will send a verification code
to the user's mobile number after they log in.
The user must provide the verification code to complete the login process.

```json
{
  "verificationType": "byLink",
  "resendTimeWindow": 60,
  "expireTimeWindow": 86400
}
```

## Access Control (Not Configured)

The project does not support any access control mechanisms, meaning that users can access all resources without any restrictions.
If you want to add access control mechanisms, you can do so in the **Access Control** chapter of Mindbricks **Authentication Module**.

## Social Logins (Not Configured)

The project does not support any social logins, meaning that users cannot log in using their social media accounts.
If you want to add social logins, you can do so in the **Social Logins** chapter of Mindbricks **Authentication Module**.

## User Properties (Not Configured)

The project does not support any user properties, meaning that users can only have the default properties defined in the user data object.
If you want to add user properties, you can do so in the **User Properties** chapter of Mindbricks **Authentication Module**.

To see a detailed configuration of the user properties, please check the **User Data Object** docmentation below.

## Auth Service Data Objects

The service uses a **PostgreSQL** database for data storage, with the database name set to `librarymanagementsystem-auth-service`.

Data deletion is managed using a **soft delete** strategy. Instead of removing records from the database, they are flagged as inactive by setting the `isActive` field to `false`.

| Object Name       | Description                                                                        | Public Access |
| ----------------- | ---------------------------------------------------------------------------------- | ------------- |
| `user`            | A data object that stores the user information and handles login settings.         | No            |
| `userGroup`       | A data object that stores the user group information.                              | Yes           |
| `userGroupMember` | A data object that stores the members of the user group.                           | Yes           |
| `authShareToken`  | A data object that stores the share tokens for tokenized access to shared objects. | No            |

## user Data Object

### Object Overview

**Description:** A data object that stores the user information and handles login settings.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement.
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration

- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** No — If enabled, anonymous users may access this object’s data depending on route-level rules.

### Redis Entity Caching

This data object is configured for Redis entity caching, which improves data retrieval performance by storing frequently accessed data in Redis.
Each time a new instance is created, updated or deleted, the cache is updated accordingly. Any get requests by id will first check the cache before querying the database.
If you want to use the cache by other select criteria, you can configure any data property as a Redis cluster.

### Properties Schema

| Property         | Type    | Required | Description                                                                       |
| ---------------- | ------- | -------- | --------------------------------------------------------------------------------- |
| `email`          | String  | Yes      | A string value to represent the user&#39;s email.                                 |
| `password`       | String  | Yes      | A string value to represent the user&#39;s password. It will be stored as hashed. |
| `name`           | String  | Yes      | A string value to represent the first and middle names of the user                |
| `surname`        | String  | Yes      | A string value to represent the family name of the user                           |
| `avatar`         | String  | No       | The avatar url of the user. A random avatar will be generated if not provided     |
| `roleId`         | String  | Yes      | A string value to represent the roleId of the user.                               |
| `mobile`         | String  | No       | A string value to represent the user&#39;s mobile number.                         |
| `mobileVerified` | Boolean | Yes      | A boolean value to represent the mobile verification status of the user.          |
| `emailVerified`  | Boolean | Yes      | A boolean value to represent the email verification status of the user.           |

- Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.

### Default Values

Default values are automatically assigned to properties when a new object is created, if no value is provided in the request body.
Since default values are applied on db level, they should be literal values, not expressions.If you want to use expressions, you can use transposed parameters in any crud route to set default values dynamically.

- **roleId**: user

### Always Create with Default Values

Some of the default values are set to be always used when creating a new object, even if the property value is provided in the request body. It ensures that the property is always initialized with a default value when the object is created.

- **roleId**: Will be created with value `user`

- **mobileVerified**: Will be created with value `false`

- **emailVerified**: Will be created with value `false`

### Constant Properties

`email`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.

### Auto Update Properties

`name` `surname` `avatar` `mobile`

An update crud route created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body.
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update route's body parameters and can be updated by the user if any value is provided in the request body.

### Hashed Properties

`password`

Hashed properties are stored in the database as a hash value, providing an additional layer of security for sensitive data.

### Elastic Search Indexing

`email` `name` `surname` `roleId` `mobile` `mobileVerified` `emailVerified`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API.
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.

### Database Indexing

`email`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.

### Unique Properties

`email`

Unique properties are enforced to have distinct values across all instances of the data object, preventing duplicate entries.
Note that a unique property is automatically indexed in the database so you will not need to set the `Indexed in DB` option.

### Cache Select Properties

`email`

Cache select properties are used to collect data from Redis entity cache with a different key than the data object id.
This allows you to cache data that is not directly related to the data object id, but a frequently used filter.

### Secondary Key Properties

`email`

Secondary key properties are used to create an additional indexed identifiers for the data object, allowing for alternative access patterns.
Different than normal indexed properties, secondary keys will act as primary keys and Mindbricks will provide automatic secondary key db utility functions to access the data object by the secondary key.

### Filter Properties

`email` `password` `name` `surname` `avatar` `roleId` `mobile` `mobileVerified` `emailVerified`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as route parameters in the listing CRUD routes that have "Auto Params" enabled.

- **email**: String has a filter named `email`

- **password**: String has a filter named `password`

- **name**: String has a filter named `name`

- **surname**: String has a filter named `surname`

- **avatar**: String has a filter named `avatar`

- **roleId**: String has a filter named `roleId`

- **mobile**: String has a filter named `mobile`

- **mobileVerified**: Boolean has a filter named `mobileVerified`

- **emailVerified**: Boolean has a filter named `emailVerified`

## userGroup Data Object

### Object Overview

**Description:** A data object that stores the user group information.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement.
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration

- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** Yes — If enabled, anonymous users may access this object’s data depending on route-level rules.

### Redis Entity Caching

This data object is configured for Redis entity caching, which improves data retrieval performance by storing frequently accessed data in Redis.
Each time a new instance is created, updated or deleted, the cache is updated accordingly. Any get requests by id will first check the cache before querying the database.
If you want to use the cache by other select criteria, you can configure any data property as a Redis cluster.

### Properties Schema

| Property    | Type   | Required | Description                                  |
| ----------- | ------ | -------- | -------------------------------------------- |
| `groupName` | String | Yes      | A string value to represent the group name.  |
| `avatar`    | String | No       | A string value to represent the groups icon. |

- Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.

### Auto Update Properties

`groupName` `avatar`

An update crud route created with the option `Auto Params` enabled will automatically update these properties with the provided values in the request body.
If you want to update any property in your own business logic not by user input, you can set the `Allow Auto Update` option to false.
These properties will be added to the update route's body parameters and can be updated by the user if any value is provided in the request body.

### Hashed Properties

`avatar`

Hashed properties are stored in the database as a hash value, providing an additional layer of security for sensitive data.

### Elastic Search Indexing

`groupName`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API.
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.

### Cache Select Properties

`groupName`

Cache select properties are used to collect data from Redis entity cache with a different key than the data object id.
This allows you to cache data that is not directly related to the data object id, but a frequently used filter.

### Filter Properties

`groupName` `avatar`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as route parameters in the listing CRUD routes that have "Auto Params" enabled.

- **groupName**: String has a filter named `groupName`

- **avatar**: String has a filter named `avatar`

## userGroupMember Data Object

### Object Overview

**Description:** A data object that stores the members of the user group.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement.
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration

- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** Yes — If enabled, anonymous users may access this object’s data depending on route-level rules.

### Redis Entity Caching

This data object is configured for Redis entity caching, which improves data retrieval performance by storing frequently accessed data in Redis.
Each time a new instance is created, updated or deleted, the cache is updated accordingly. Any get requests by id will first check the cache before querying the database.
If you want to use the cache by other select criteria, you can configure any data property as a Redis cluster.

### Composite Indexes

- **uniqueUserInGroup**: [userId, groupId]
  This composite index is defined to optimize query performance for complex queries involving multiple fields.

The index also defines a conflict resolution strategy for duplicate key violations.

When a new record would violate this composite index, the following action will be taken:

**On Duplicate**: `doUpdate`

The existing record will be updated with the new data.No error will be thrown.

### Properties Schema

| Property  | Type | Required | Description                                                                    |
| --------- | ---- | -------- | ------------------------------------------------------------------------------ |
| `groupId` | ID   | Yes      | An ID value to represent the group that the user is asssigned as a memeber to. |
| `userId`  | ID   | Yes      | An ID value to represent the user that is assgined as a member to the group.   |
| `ownerId` | ID   | Yes      | An ID value to represent the admin user who assgined the member.               |

- Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.

### Constant Properties

`groupId` `userId` `ownerId`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.

### Elastic Search Indexing

`groupId` `userId` `ownerId`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API.
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.

### Database Indexing

`groupId` `userId` `ownerId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.

### Cache Select Properties

`groupId` `userId` `ownerId`

Cache select properties are used to collect data from Redis entity cache with a different key than the data object id.
This allows you to cache data that is not directly related to the data object id, but a frequently used filter.

### Relation Properties

`groupId` `userId` `ownerId`

Mindbricks supports relations between data objects, allowing you to define how objects are linked together.
You can define relations in the data object properties, which will be used to create foreign key constraints in the database.
For complex joins operations, Mindbricks supportsa BFF pattern, where you can view dynamic and static views based on Elastic Search Indexes.
Use db level relations for simple one-to-one or one-to-many relationships, and use BFF views for complex joins that require multiple data objects to be joined together.

- **groupId**: ID
  Relation to `userGroup`.id

The target object is a parent object, meaning that the relation is a one-to-many relationship from target to this object.

On Delete: Set Null
Required: No

- **userId**: ID
  Relation to `user`.id

The target object is a sibling object, meaning that the relation is a many-to-one or one-to-one relationship from this object to the target.

On Delete: Set Null
Required: No

- **ownerId**: ID
  Relation to `user`.id

The target object is a sibling object, meaning that the relation is a many-to-one or one-to-one relationship from this object to the target.

On Delete: Set Null
Required: No

### Session Data Properties

`ownerId`

Session data properties are used to store data that is specific to the user session, allowing for personalized experiences and temporary data storage.
If a property is configured as session data, it will be automatically mapped to the related field in the user session during CRUD operations.
Note that session data properties can not be mutated by the user, but only by the system.

- **ownerId**: ID property will be mapped to the session parameter `userId`.

### Filter Properties

`groupId` `userId` `ownerId`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as route parameters in the listing CRUD routes that have "Auto Params" enabled.

- **groupId**: ID has a filter named `groupId`

- **userId**: ID has a filter named `userId`

- **ownerId**: ID has a filter named `ownerId`

## authShareToken Data Object

### Object Overview

**Description:** A data object that stores the share tokens for tokenized access to shared objects.

This object represents a core data structure within the service and acts as the blueprint for database interaction, API generation, and business logic enforcement.
It is defined using the `ObjectSettings` pattern, which governs its behavior, access control, caching strategy, and integration points with other systems such as Stripe and Redis.

### Core Configuration

- **Soft Delete:** Enabled — Determines whether records are marked inactive (`isActive = false`) instead of being physically deleted.
- **Public Access:** No — If enabled, anonymous users may access this object’s data depending on route-level rules.

### Properties Schema

| Property           | Type   | Required | Description                                                                                                          |
| ------------------ | ------ | -------- | -------------------------------------------------------------------------------------------------------------------- |
| `configName`       | String | Yes      | A string value to represent the related configuration of the shared token.                                           |
| `objectName`       | String | Yes      | A string value to represent the type name of the shared object like `report`, `document`.                            |
| `objectId`         | ID     | Yes      | An ID value to represent the shared target data object instance.                                                     |
| `ownerId`          | ID     | Yes      | An ID value to represent the user who shared the object by creating this token.                                      |
| `peopleOption`     | String | Yes      | A string value to represent the access option of the share token. It can be either anyoneWithLink or specificEmails. |
| `tokenPermissions` |        | Yes      | A string array to store the names of permissions (or roles) by the sharing user.                                     |
| `allowedEmails`    |        | Yes      | A string array to store the allowed emails if the peopleOption is specificEmails.                                    |
| `expireDate`       | Date   | Yes      | A date value to specify the expire date of the token. Null for infinite token.                                       |

- Required properties are mandatory for creating objects and must be provided in the request body if no default value is set.

### Constant Properties

`configName` `objectName` `objectId` `ownerId` `peopleOption` `tokenPermissions` `allowedEmails` `expireDate`

Constant properties are defined to be immutable after creation, meaning they cannot be updated or changed once set. They are typically used for properties that should remain constant throughout the object's lifecycle.
A property is set to be constant if the `Allow Update` option is set to `false`.

### Elastic Search Indexing

`configName` `objectName` `objectId` `ownerId` `peopleOption` `tokenPermissions` `allowedEmails` `expireDate`

Properties that are indexed in Elastic Search will be searchable via the Elastic Search API.
While all properties are stored in the elastic search index of the data object, only those marked for Elastic Search indexing will be available for search queries.

### Database Indexing

`configName` `objectId` `ownerId`

Properties that are indexed in the database will be optimized for query performance, allowing for faster data retrieval.
Make a property indexed in the database if you want to use it frequently in query filters or sorting.

### Session Data Properties

`ownerId`

Session data properties are used to store data that is specific to the user session, allowing for personalized experiences and temporary data storage.
If a property is configured as session data, it will be automatically mapped to the related field in the user session during CRUD operations.
Note that session data properties can not be mutated by the user, but only by the system.

- **ownerId**: ID property will be mapped to the session parameter `userId`.

This property is also used to store the owner of the session data, allowing for ownership checks and access control.

### Filter Properties

`configName` `objectName` `objectId` `ownerId` `peopleOption` `tokenPermissions` `allowedEmails` `expireDate`

Filter properties are used to define parameters that can be used in query filters, allowing for dynamic data retrieval based on user input or predefined criteria.
These properties are automatically mapped as route parameters in the listing CRUD routes that have "Auto Params" enabled.

- **configName**: String has a filter named `configName`

- **objectName**: String has a filter named `objectName`

- **objectId**: ID has a filter named `objectId`

- **ownerId**: ID has a filter named `ownerId`

- **peopleOption**: String has a filter named `peopleOption`

- **tokenPermissions**: has a filter named `tokenPermissions`

- **allowedEmails**: has a filter named `allowedEmails`

- **expireDate**: Date has a filter named `expireDate`
